import { BlockHeightKey } from '../cache/index';
import { DefaultStateEvaluator, EvalStateResult } from '../core/index';
import { LoggerFactory } from '../logging/index';
/**
 * An implementation of DefaultStateEvaluator that adds caching capabilities
 */
export class CacheableStateEvaluator extends DefaultStateEvaluator {
    constructor(arweave, cache, executionContextModifiers = []) {
        super(arweave, executionContextModifiers);
        this.cache = cache;
        this.cLogger = LoggerFactory.INST.create('CacheableStateEvaluator');
    }
    async eval(executionContext, currentTx) {
        const requestedBlockHeight = executionContext.blockHeight;
        this.cLogger.debug(`Requested state block height: ${requestedBlockHeight}`);
        const cachedState = executionContext.cachedState;
        if ((cachedState === null || cachedState === void 0 ? void 0 : cachedState.cachedHeight) === requestedBlockHeight) {
            return cachedState.cachedValue;
        }
        this.cLogger.debug('executionContext.sortedInteractions', executionContext.sortedInteractions.length);
        const sortedInteractionsUpToBlock = executionContext.sortedInteractions.filter((tx) => {
            return tx.node.block.height <= executionContext.blockHeight;
        });
        let missingInteractions = sortedInteractionsUpToBlock.slice();
        this.cLogger.debug('missingInteractions', missingInteractions.length);
        // if there was anything to cache...
        if (sortedInteractionsUpToBlock.length > 0) {
            if (cachedState != null) {
                this.cLogger.debug(`Cached state for ${executionContext.contractDefinition.txId}`, {
                    cachedHeight: cachedState.cachedHeight,
                    requestedBlockHeight
                });
                // verify if for the requested block height there are any interactions
                // with higher block height than latest value stored in cache - basically if there are any non-cached interactions.
                missingInteractions = sortedInteractionsUpToBlock.filter(({ node }) => node.block.height > cachedState.cachedHeight && node.block.height <= requestedBlockHeight);
            }
            this.cLogger.debug(`Interactions until [${requestedBlockHeight}]`, {
                total: sortedInteractionsUpToBlock.length,
                cached: sortedInteractionsUpToBlock.length - missingInteractions.length
            });
            // TODO: this is tricky part, needs proper description
            // for now: it prevents from infinite loop calls between calls that are making
            // internal interact writes.
            for (const entry of currentTx || []) {
                if (entry.contractTxId === executionContext.contractDefinition.txId) {
                    const index = missingInteractions.findIndex((tx) => tx.node.id === entry.interactionTxId);
                    if (index !== -1) {
                        this.cLogger.debug('Inf. Loop fix - removing interaction', {
                            height: missingInteractions[index].node.block.height,
                            contractTxId: entry.contractTxId,
                            interactionTxId: entry.interactionTxId
                        });
                        missingInteractions.splice(index);
                    }
                }
            }
            // if cache is up-to date - return immediately to speed-up the whole process
            if (missingInteractions.length === 0 && cachedState) {
                this.cLogger.debug(`State up to requested height [${requestedBlockHeight}] fully cached!`);
                return cachedState.cachedValue;
            }
        }
        const baseState = cachedState == null ? executionContext.contractDefinition.initState : cachedState.cachedValue.state;
        const baseValidity = cachedState == null ? {} : cachedState.cachedValue.validity;
        // eval state for the missing transactions - starting from latest value from cache.
        return await this.doReadState(missingInteractions, new EvalStateResult(baseState, baseValidity), executionContext, currentTx);
    }
    async onStateEvaluated(lastInteraction, executionContext, state) {
        if (lastInteraction.dry) {
            return;
        }
        this.cLogger.debug(`onStateEvaluated: cache update for contract ${executionContext.contractDefinition.txId} [${lastInteraction.block.height}]`);
        await this.cache.put(new BlockHeightKey(executionContext.contractDefinition.txId, lastInteraction.block.height), state);
    }
    async onStateUpdate(currentInteraction, executionContext, state) {
        if (currentInteraction.dry) {
            return;
        }
        if (executionContext.evaluationOptions.updateCacheForEachInteraction) {
            await this.cache.put(new BlockHeightKey(executionContext.contractDefinition.txId, currentInteraction.block.height), state);
        }
        await super.onStateUpdate(currentInteraction, executionContext, state);
    }
    async latestAvailableState(contractTxId, blockHeight) {
        return (await this.cache.getLessOrEqual(contractTxId, blockHeight));
    }
    async onInternalWriteStateUpdate(currentInteraction, contractTxId, state) {
        if (currentInteraction.dry) {
            return;
        }
        this.cLogger.debug('Internal write state update:', {
            height: currentInteraction.block.height,
            contractTxId,
            state
        });
        await this.cache.put(new BlockHeightKey(contractTxId, currentInteraction.block.height), state);
    }
}
//# sourceMappingURL=CacheableStateEvaluator.js.map