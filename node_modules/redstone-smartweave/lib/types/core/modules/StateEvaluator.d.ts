import { BlockHeightCacheResult, CurrentTx, ExecutionContext, GQLNodeInterface } from '../..';
/**
 * Implementors of this class are responsible for evaluating contract's state
 * - based on the execution context.
 */
export interface StateEvaluator {
    eval<State>(executionContext: ExecutionContext<State>, currentTx: CurrentTx[]): Promise<EvalStateResult<State>>;
    /**
     * a hook that is called on each state update (i.e. after evaluating state for each interaction)
     */
    onStateUpdate<State>(currentInteraction: GQLNodeInterface, executionContext: ExecutionContext<State>, state: EvalStateResult<State>): Promise<void>;
    /**
     * a hook that is called after state has been fully evaluated
     */
    onStateEvaluated<State>(lastInteraction: GQLNodeInterface, executionContext: ExecutionContext<State>, state: EvalStateResult<State>): Promise<void>;
    onInternalWriteStateUpdate<State>(currentInteraction: GQLNodeInterface, contractTxId: string, state: EvalStateResult<State>): Promise<void>;
    /**
     * a hook that is called before communicating with other contract
     * note to myself: putting values into cache only "onContractCall" may degrade performance.
     * For example"
     * block 722317 - contract A calls B
     * block 722727 - contract A calls B
     * block 722695 - contract B calls A
     * If we update cache only on contract call - for the last above call (B->A)
     * we would retrieve state cached for 722317. If there are any transactions
     * between 722317 and 722695 - the performance will be degraded.
     */
    onContractCall<State>(currentInteraction: GQLNodeInterface, executionContext: ExecutionContext<State>, state: EvalStateResult<State>): Promise<void>;
    latestAvailableState<State>(contractTxId: string, blockHeight: number): Promise<BlockHeightCacheResult<EvalStateResult<State>> | null>;
}
export declare class EvalStateResult<State> {
    readonly state: State;
    readonly validity: Record<string, boolean>;
    constructor(state: State, validity: Record<string, boolean>);
}
export declare class DefaultEvaluationOptions implements EvaluationOptions {
    ignoreExceptions: boolean;
    waitForConfirmation: boolean;
    fcpOptimization: boolean;
    updateCacheForEachInteraction: boolean;
    internalWrites: boolean;
    maxCallDepth: number;
    maxInteractionEvaluationTimeSeconds: number;
    stackTrace: {
        saveState: boolean;
    };
}
export interface EvaluationOptions {
    ignoreExceptions: boolean;
    waitForConfirmation: boolean;
    fcpOptimization: boolean;
    updateCacheForEachInteraction: boolean;
    internalWrites: boolean;
    maxCallDepth: number;
    maxInteractionEvaluationTimeSeconds: number;
    stackTrace: {
        saveState: boolean;
    };
}
//# sourceMappingURL=StateEvaluator.d.ts.map