"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultStateEvaluator = void 0;
const _smartweave_1 = require("../../..");
// FIXME: currently this is tightly coupled with the HandlerApi
class DefaultStateEvaluator {
    constructor(arweave, executionContextModifiers = []) {
        this.arweave = arweave;
        this.executionContextModifiers = executionContextModifiers;
        this.logger = _smartweave_1.LoggerFactory.INST.create('DefaultStateEvaluator');
        this.transactionStateCache = new _smartweave_1.MemCache();
        this.tagsParser = new _smartweave_1.TagsParser();
    }
    async eval(executionContext, currentTx) {
        return this.doReadState(executionContext.sortedInteractions, new _smartweave_1.EvalStateResult(executionContext.contractDefinition.initState, {}), executionContext, currentTx);
    }
    async doReadState(missingInteractions, baseState, executionContext, currentTx) {
        const stateEvaluationBenchmark = _smartweave_1.Benchmark.measure();
        const { ignoreExceptions, stackTrace, internalWrites } = executionContext.evaluationOptions;
        const { contract, contractDefinition, sortedInteractions } = executionContext;
        let currentState = baseState.state;
        let validity = (0, _smartweave_1.deepCopy)(baseState.validity);
        this.logger.info(`Evaluating state for ${executionContext.contractDefinition.txId} [${missingInteractions.length} non-cached of ${executionContext.sortedInteractions.length} all]`);
        this.logger.debug('Base state:', baseState.state);
        let lastEvaluatedInteraction = null;
        let errorMessage = null;
        for (const missingInteraction of missingInteractions) {
            const singleInteractionBenchmark = _smartweave_1.Benchmark.measure();
            const interactionTx = missingInteraction.node;
            this.logger.debug(`[${contractDefinition.txId}][${missingInteraction.node.id}][${missingInteraction.node.block.height}]: ${missingInteractions.indexOf(missingInteraction) + 1}/${missingInteractions.length} [of all:${sortedInteractions.length}]`);
            const state = await this.onNextIteration(interactionTx, executionContext);
            const isInteractWrite = this.tagsParser.isInteractWrite(missingInteraction, contractDefinition.txId);
            this.logger.debug('interactWrite?:', isInteractWrite);
            // other contract makes write ("writing contract") on THIS contract
            if (isInteractWrite && internalWrites) {
                // evaluating txId of the contract that is writing on THIS contract
                const writingContractTxId = this.tagsParser.getContractTag(missingInteraction);
                this.logger.debug('Loading writing contract', writingContractTxId);
                const interactionCall = contract
                    .getCallStack()
                    .addInteractionData({ interaction: null, interactionTx, currentTx });
                // creating a Contract instance for the "writing" contract
                const writingContract = executionContext.smartweave.contract(writingContractTxId, executionContext.contract, interactionTx);
                this.logger.debug('Reading state of the calling contract', interactionTx.block.height);
                /**
                Reading the state of the writing contract.
                This in turn will cause the state of THIS contract to be
                updated in cache - see {@link ContractHandlerApi.assignWrite}
                */
                await writingContract.readState(interactionTx.block.height, [
                    ...(currentTx || []),
                    {
                        contractTxId: contractDefinition.txId,
                        interactionTxId: missingInteraction.node.id
                    }
                ]);
                // loading latest state of THIS contract from cache
                const newState = await this.latestAvailableState(contractDefinition.txId, interactionTx.block.height);
                this.logger.debug('New state:', {
                    height: interactionTx.block.height,
                    newState,
                    txId: contractDefinition.txId
                });
                if (newState !== null) {
                    currentState = (0, _smartweave_1.deepCopy)(newState.cachedValue.state);
                    validity[interactionTx.id] = newState.cachedValue.validity[interactionTx.id];
                }
                else {
                    validity[interactionTx.id] = false;
                }
                lastEvaluatedInteraction = interactionTx;
                interactionCall.update({
                    cacheHit: false,
                    intermediaryCacheHit: false,
                    outputState: stackTrace.saveState ? currentState : undefined,
                    executionTime: singleInteractionBenchmark.elapsed(true),
                    valid: validity[interactionTx.id],
                    errorMessage: errorMessage
                });
                this.logger.debug('New state after internal write', { contractTxId: contractDefinition.txId, newState });
            }
            else {
                // "direct" interaction with this contract - "standard" processing
                const inputTag = this.tagsParser.getInputTag(missingInteraction, executionContext.contractDefinition.txId);
                if (!inputTag) {
                    this.logger.error(`Skipping tx - Input tag not found for ${interactionTx.id}`);
                    continue;
                }
                const input = this.parseInput(inputTag);
                if (!input) {
                    this.logger.error(`Skipping tx - invalid Input tag - ${interactionTx.id}`);
                    continue;
                }
                const interaction = {
                    input,
                    caller: interactionTx.owner.address
                };
                let intermediaryCacheHit = false;
                const interactionData = {
                    interaction,
                    interactionTx,
                    currentTx
                };
                this.logger.debug('Interaction:', interaction);
                const interactionCall = contract.getCallStack().addInteractionData(interactionData);
                if (state !== null) {
                    this.logger.debug('Found in intermediary cache');
                    intermediaryCacheHit = true;
                    currentState = state.state;
                    validity = state.validity;
                }
                else {
                    const result = await executionContext.handler.handle(executionContext, new _smartweave_1.EvalStateResult(currentState, validity), interactionData);
                    errorMessage = result.errorMessage;
                    this.logResult(result, interactionTx, executionContext);
                    if (result.type === 'exception' && ignoreExceptions !== true) {
                        throw new Error(`Exception while processing ${JSON.stringify(interaction)}:\n${result.errorMessage}`);
                    }
                    validity[interactionTx.id] = result.type === 'ok';
                    currentState = result.state;
                    // cannot simply take last element of the missingInteractions
                    // as there is no certainty that it has been evaluated (e.g. issues with input tag).
                    lastEvaluatedInteraction = interactionTx;
                    this.logger.debug('Interaction evaluation', singleInteractionBenchmark.elapsed());
                }
                interactionCall.update({
                    cacheHit: false,
                    intermediaryCacheHit,
                    outputState: stackTrace.saveState ? currentState : undefined,
                    executionTime: singleInteractionBenchmark.elapsed(true),
                    valid: validity[interactionTx.id],
                    errorMessage: errorMessage
                });
            }
            await this.onStateUpdate(interactionTx, executionContext, new _smartweave_1.EvalStateResult(currentState, validity));
            // I'm really NOT a fan of this "modify" feature, but I don't have idea how to better
            // implement the "evolve" feature
            for (const { modify } of this.executionContextModifiers) {
                executionContext = await modify(currentState, executionContext);
            }
        }
        this.logger.debug('State evaluation total:', stateEvaluationBenchmark.elapsed());
        const evalStateResult = new _smartweave_1.EvalStateResult(currentState, validity);
        // state could have been full retrieved from cache
        // or there were no interactions below requested block height
        if (lastEvaluatedInteraction !== null) {
            await this.onStateEvaluated(lastEvaluatedInteraction, executionContext, evalStateResult);
        }
        return evalStateResult;
    }
    logResult(result, currentTx, executionContext) {
        if (result.type === 'exception') {
            this.logger.error(`Executing of interaction: [${executionContext.contractDefinition.srcTxId} -> ${currentTx.id}] threw exception:`, `${result.errorMessage}`);
        }
        if (result.type === 'error') {
            this.logger.warn(`Executing of interaction: [${executionContext.contractDefinition.srcTxId} -> ${currentTx.id}] returned error:`, result.errorMessage);
        }
    }
    parseInput(inputTag) {
        try {
            return JSON.parse(inputTag.value);
        }
        catch (e) {
            this.logger.error(e);
            return null;
        }
    }
    async onStateUpdate(currentInteraction, executionContext, state) {
        if (executionContext.evaluationOptions.fcpOptimization && !currentInteraction.dry) {
            this.transactionStateCache.put(`${executionContext.contractDefinition.txId}|${currentInteraction.id}`, (0, _smartweave_1.deepCopy)(state));
        }
    }
    async onNextIteration(currentInteraction, executionContext) {
        const cacheKey = `${executionContext.contractDefinition.txId}|${currentInteraction.id}`;
        const cachedState = this.transactionStateCache.get(cacheKey);
        if (cachedState == null) {
            return null;
        }
        else {
            return (0, _smartweave_1.deepCopy)(cachedState);
        }
    }
    onContractCall(currentInteraction, executionContext, state) {
        return Promise.resolve(undefined);
    }
    onStateEvaluated(lastInteraction, executionContext, state) {
        return Promise.resolve(undefined);
    }
    async latestAvailableState(contractTxId, blockHeight) {
        return null;
    }
    onInternalWriteStateUpdate(currentInteraction, contractTxId, state) {
        return Promise.resolve(undefined);
    }
}
exports.DefaultStateEvaluator = DefaultStateEvaluator;
//# sourceMappingURL=DefaultStateEvaluator.js.map