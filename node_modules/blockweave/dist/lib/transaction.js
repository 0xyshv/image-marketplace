"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseObject_1 = require("../utils/baseObject");
const buffer_1 = require("../utils/buffer");
const tag_1 = require("./tag");
const merkle_1 = __importDefault(require("../utils/merkle"));
const deepHash_1 = __importDefault(require("../utils/deepHash"));
const transactionUploader_1 = require("../utils/transactionUploader");
const fee_1 = __importDefault(require("../utils/fee"));
const blockweave_1 = __importDefault(require("../blockweave"));
class Transaction extends baseObject_1.BaseObject {
    format = 2;
    id = '';
    // tslint:disable-next-line: variable-name
    last_tx = '';
    owner = '';
    tags = [];
    target = '';
    quantity = '0';
    // tslint:disable-next-line: variable-name
    data_size = '0';
    data = new Uint8Array();
    // tslint:disable-next-line: variable-name
    data_root = '';
    reward = '0';
    signature = '';
    chunks;
    blockweave;
    api;
    merkle;
    jwk;
    // private _raw: TransactionInterface = {};
    constructor(attributes = {}, blockweave, jwk = 'use_wallet') {
        super();
        Object.assign(this, attributes);
        // If something passes in a Tx that has been toJSON'ed and back,
        // or where the data was filled in from /tx/data endpoint.
        // data will be b64url encoded, so decode it.
        if (typeof this.data === 'string') {
            this.data = (0, buffer_1.b64UrlToBuffer)(this.data);
        }
        if (attributes.tags) {
            this.tags = attributes.tags.map((tag) => new tag_1.Tag(tag.name, tag.value));
        }
        this.blockweave = blockweave;
        this.jwk = jwk;
        this.merkle = new merkle_1.default();
    }
    static async create(blockweave, attributes, jwk) {
        const transaction = {};
        Object.assign(transaction, attributes);
        if (!attributes.data && !(attributes.target && attributes.quantity)) {
            throw new Error('A new Blockweave transaction must have a `data`, or `target` and `quantity`.');
        }
        if (!attributes.owner) {
            if (jwk && jwk !== 'use_wallet') {
                transaction.owner = jwk.n;
            }
        }
        if (attributes.last_tx === undefined) {
            transaction.last_tx = await blockweave.transactions.getTransactionAnchor();
        }
        if (typeof attributes.data === 'string') {
            attributes.data = (0, buffer_1.stringToBuffer)(attributes.data);
        }
        if (attributes.data &&
            (attributes.data.constructor.name === 'ArrayBuffer' || attributes.data.constructor.name === 'Buffer')) {
            attributes.data = new Uint8Array(attributes.data);
        }
        // Replaced instanceof with getting the constructor.name, if not, jest on jsdom will fail.
        if (attributes.data && attributes.data.constructor.name !== 'Uint8Array') {
            throw new Error(`Expected data to be a string, Uint8Array or ArrayBuffer. ${attributes.data.constructor.name} received.`);
        }
        if (attributes.reward === undefined) {
            const length = attributes.data ? attributes.data.byteLength : 0;
            transaction.reward = await blockweave.transactions.getPrice(length, transaction.target);
        }
        // here we should call prepare chunk
        transaction.data_root = '';
        transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : '0';
        transaction.data = attributes.data || new Uint8Array(0);
        const createdTransaction = new Transaction(transaction, blockweave, jwk);
        await createdTransaction.getSignatureData();
        return createdTransaction;
    }
    /**
     * Add a new tag to this transaction.
     * @param  {string} name
     * @param  {string} value
     */
    addTag(name, value) {
        this.tags.push(new tag_1.Tag((0, buffer_1.stringToB64Url)(name), (0, buffer_1.stringToB64Url)(value)));
    }
    /**
     * Set the transaction to a new owner.
     * @param  {string} newOwner
     */
    setOwner(newOwner) {
        this.owner = newOwner;
    }
    /**
     * Set the signature of the transaction to a new one.
     * @param {string} id
     * @param {string} owner
     * @param {Tag[]} tags
     * @param {string} signature
     */
    setSignature({ id, owner, tags, signature }) {
        this.id = id;
        this.owner = owner;
        if (tags) {
            this.tags = tags;
        }
        this.signature = signature;
    }
    /**
     * Prepare the data as chunks.
     * @param  {Uint8Array} data
     */
    async prepareChunks(data) {
        if (!this.chunks && data.byteLength > 0) {
            this.chunks = await this.merkle.generateTransactionChunks(data);
            this.data_root = (0, buffer_1.bufferTob64Url)(this.chunks.data_root);
        }
        if (!this.chunks && data.byteLength === 0) {
            this.chunks = {
                chunks: [],
                data_root: new Uint8Array(),
                proofs: [],
            };
            this.data_root = '';
        }
    }
    /**
     * Returns a chunk in a format suitable for posting to /chunk.
     * @param  {number} idx
     * @param  {Uint8Array} data
     * @returns Chunk data formated for deploy.
     */
    getChunk(idx, data) {
        if (!this.chunks) {
            this.prepareChunks(data);
        }
        const proof = this.chunks.proofs[idx];
        const chunk = this.chunks.chunks[idx];
        return {
            data_root: this.data_root,
            data_size: this.data_size,
            data_path: (0, buffer_1.bufferTob64Url)(proof.proof),
            offset: proof.offset.toString(),
            chunk: (0, buffer_1.bufferTob64Url)(data.slice(chunk.minByteRange, chunk.maxByteRange)),
        };
    }
    async getSignatureData() {
        switch (this.format) {
            case 1:
                const tags = this.tags.reduce((accumulator, tag) => {
                    return (0, buffer_1.concatBuffers)([
                        accumulator,
                        tag.get('name', { decode: true, string: false }),
                        tag.get('value', { decode: true, string: false }),
                    ]);
                }, new Uint8Array());
                return (0, buffer_1.concatBuffers)([
                    this.get('owner', { decode: true, string: false }),
                    this.get('target', { decode: true, string: false }),
                    this.get('data', { decode: true, string: false }),
                    (0, buffer_1.stringToBuffer)(this.quantity),
                    (0, buffer_1.stringToBuffer)(this.reward),
                    this.get('last_tx', { decode: true, string: false }),
                    tags,
                ]);
            case 2:
                await this.prepareChunks(this.data);
                const tagList = this.tags.map((tag) => [
                    tag.get('name', { decode: true, string: false }),
                    tag.get('value', { decode: true, string: false }),
                ]);
                const toHash = [
                    (0, buffer_1.stringToBuffer)(this.format.toString()),
                    this.get('owner', { decode: true, string: false }),
                    this.get('target', { decode: true, string: false }),
                    (0, buffer_1.stringToBuffer)(this.quantity),
                    (0, buffer_1.stringToBuffer)(this.reward),
                    this.get('last_tx', { decode: true, string: false }),
                    tagList,
                    (0, buffer_1.stringToBuffer)(this.data_size),
                    this.get('data_root', { decode: true, string: false }),
                ];
                return await (0, deepHash_1.default)(toHash);
            default:
                throw new Error(`Unexpected transaction format: ${this.format}`);
        }
    }
    /**
     * Verify a signed transaction.
     * @param  {Transaction} transaction
     * @returns {Promise<boolean>} A boolean value indicating whether the transaction is valid.
     */
    async verify() {
        const signaturePayload = await this.getSignatureData();
        /**
         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs
         * to be recalculated from the signature and checked against the transaction ID.
         */
        const rawSignature = this.get('signature', {
            decode: true,
            string: false,
        });
        const expectedId = (0, buffer_1.bufferTob64Url)(await blockweave_1.default.crypto.hash(rawSignature));
        if (this.id !== expectedId) {
            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
        }
        /**
         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).
         */
        return blockweave_1.default.crypto.verify(this.owner, signaturePayload, rawSignature);
    }
    /**
     * Sign a transaction with your wallet, to be able to post it to Blockweave.
     * @param {JWKInterface} jwk A JWK (Wallet address JSON representation) to sign the transaction with. Or 'use_wallet' to use the wallet from an external tool.
     * @param {SignatureOptions} options Signature options, optional.
     * @return {Promise<void>}
     */
    async sign(jwk, options) {
        if (!jwk && this.jwk) {
            jwk = this.jwk;
        }
        if (!jwk && (typeof window === 'undefined' || !window.arweaveWallet)) {
            throw new Error('An arweave JWK must be provided.');
        }
        else if (!jwk || jwk === 'use_wallet') {
            try {
                const existingPermissions = await window.arweaveWallet.getPermissions();
                if (!existingPermissions.includes('SIGN_TRANSACTION')) {
                    await window.arweaveWallet.connect(['SIGN_TRANSACTION']);
                }
            }
            catch {
                throw new Error('Unable to connect to wallet.');
            }
            try {
                const transaction = {
                    format: this.format,
                    id: this.id,
                    last_tx: this.last_tx,
                    owner: this.owner,
                    tags: this.tags,
                    target: this.target,
                    quantity: this.quantity,
                    data_size: this.data_size,
                    data: this.data,
                    data_root: this.data_root,
                    reward: this.reward,
                    signature: this.signature,
                    chunks: this.chunks,
                };
                const signedTransaction = await window.arweaveWallet.sign(transaction, options);
                this.setSignature({
                    id: signedTransaction.id,
                    owner: signedTransaction.owner,
                    tags: signedTransaction.tags,
                    signature: signedTransaction.signature,
                });
            }
            catch {
                throw new Error('Unable to sign transaction');
            }
        }
        else {
            this.setOwner(jwk.n);
            const dataToSign = await this.getSignatureData();
            const rawSignature = await blockweave_1.default.crypto.sign(jwk, dataToSign, options);
            const id = await blockweave_1.default.crypto.hash(rawSignature);
            this.setSignature({
                id: (0, buffer_1.bufferTob64Url)(id),
                owner: jwk.n,
                signature: (0, buffer_1.bufferTob64Url)(rawSignature),
            });
        }
    }
    /**
     * Post a previously signed transaction to the network.
     * @param {number} feePercent The transaction fee %, in AR.
     * @returns {Promise} Returns a promise which resolves to `{status: number; statusText: string; data: any}`.
     */
    async post(feePercent = 0.1) {
        const txUploader = new transactionUploader_1.TransactionUploader(this.blockweave, this, blockweave_1.default.crypto);
        const uploader = await txUploader.getUploader(this);
        // Emulate existing error & return value behaviour.
        try {
            while (!uploader.isComplete) {
                await uploader.uploadChunk();
            }
        }
        catch (e) {
            if (uploader.lastResponseStatus > 0) {
                return {
                    status: uploader.lastResponseStatus,
                    statusText: uploader.lastResponseError,
                    data: {
                        error: uploader.lastResponseError,
                    },
                };
            }
            throw e;
        }
        if (feePercent) {
            this.chargeFee(feePercent);
        }
        return {
            status: 200,
            statusText: 'OK',
            data: {},
        };
    }
    /**
     * @param  {JWKInterface|'use_wallet'} jwk?
     * @param  {SignatureOptions} options?
     * @param  {number} feePercent?
     * @returns {Promise<{ status: number; statusText: string; data: any }>} Returns the response `status, statusText, data}.
     */
    async signAndPost(jwk, options, feePercent) {
        await this.sign(jwk, options);
        return this.post(feePercent);
    }
    /**
     * Return an object with the same data as this class.
     * @returns - The transaction as a JSON object.
     */
    toJSON() {
        return {
            format: this.format,
            id: this.id,
            last_tx: this.last_tx,
            owner: this.owner,
            tags: this.tags,
            target: this.target,
            quantity: this.quantity,
            data_size: this.data_size,
            data: (0, buffer_1.bufferTob64Url)(this.data),
            data_root: this.data_root,
            reward: this.reward,
            signature: this.signature,
        };
    }
    /**
     * @param  {number=0.1} feePercent
     */
    async chargeFee(feePercent = 0.1) {
        if (!feePercent) {
            return;
        }
        if (feePercent > 1) {
            throw new Error('Fee percent must be between 0 and 1. Ex: 0.1 = 10%');
        }
        const fee = +this.reward * feePercent;
        const target = await (0, fee_1.default)(this.blockweave);
        if (!target || target === (await this.blockweave.wallets.jwkToAddress(this.jwk))) {
            return;
        }
        const tx = await Transaction.create(this.blockweave, {
            target,
            quantity: fee.toString(),
        }, this.jwk);
        tx.addTag('App-Name', 'Blockweave');
        tx.addTag('Service', 'Blockweave');
        tx.addTag('Action', 'post');
        tx.addTag('Message', `Deployed ${this.id}`);
        tx.addTag('Size', this.data_size);
        await tx.signAndPost(this.jwk, null, 0);
    }
}
exports.default = Transaction;
