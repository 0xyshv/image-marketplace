/// <reference types="node" />
import { TransactionInterface } from '../faces/lib/transaction';
import { TransactionStatusResponseInterface } from '../faces/lib/transactions';
import { JWKInterface } from '../faces/lib/wallet';
import { SignatureOptions } from '../faces/utils/crypto';
import Chunks from './chunks';
import Transaction from './transaction';
import 'arconnect';
import { SerializedUploader } from '../faces/utils/transactionUploader';
import { TransactionUploader } from '../utils/transactionUploader';
import Blockweave from '../blockweave';
import ArCache from '../utils/arCache';
export default class Transactions {
    private solid;
    private chunks;
    private cache;
    constructor(solid: Blockweave, chunks: Chunks, cache: ArCache);
    /**
     * Transactions should use an anchor block to allow submitting of multiple transactions per block.
     * @return {Promise<string>} An anchor block ID.
     */
    getTransactionAnchor(): Promise<string>;
    /**
     * Get the network fee for bytes of data and an optional wallet address.
     * The optional wallet address is required because the first transaction to a wallet has an extra fee to prevent spamming.
     * @param {number} byteSize The number of bytes of data.
     * @param {string} walletAddress The wallet address.
     * @return {Promise<string>} The network fee in Winston.
     */
    getPrice(byteSize: number, targetAddress?: string): Promise<string>;
    /**
     * Get a Transaction by its ID.
     * @param {string} id The transaction ID.
     * @return {Promise<TransactionInterface>} The transaction.
     * @return {Promise<Transaction>} A promise which resolves into the Transaction object.
     */
    get(id: string): Promise<Transaction>;
    /**
     * Get a Transaction object, from raw transaction data.
     * @param {Partial<TransactionInterface>} transaction The transaction data.
     * @return {Promise<Transaction>} A promise which resolves into the Transaction object.
     */
    fromRaw(attributes?: Partial<TransactionInterface>): Transaction;
    /**
     * Do a quick search for a tagname and a tag value.
     * @deprecated Use https://npmjs.com/@textury/ardb instead.
     * @returns {Promise<string[]>} An array (up to 10) of strings containing the transaction IDs matching the search.
     */
    search(tagName: string, tagValue: string): Promise<string[]>;
    /**
     * Get the provided transaction ID current status on the network.
     * @param {string} id The transaction ID.
     * @return {Promise<TransactionStatusResponse>} A promise which resolves into the TransactionStatusResponse object.
     */
    getStatus(id: string): Promise<TransactionStatusResponseInterface>;
    /**
     * Get the transaction data for a transaction ID.
     * @param {string} id The transaction ID.
     * @param {{decode: boolean; string: boolean;}} options Options for the data, optional.
     * @return {Promise<string>} The transaction data.
     * @return {Promise<Uint8Array>} The transaction data as an Uint8Array.
     */
    getData(id: string, options?: {
        decode?: boolean;
        string?: boolean;
    }): Promise<string | Uint8Array>;
    /**
     * Sign a transaction with your wallet, to be able to post it to Blockweave.
     * @param {Transaction} transaction The transaction to sign.
     * @param {JWKInterface} jwk A JWK (Wallet address JSON representation) to sign the transaction with. Or 'use_wallet' to use the wallet from an external tool.
     * @param {SignatureOptions} options Signature options, optional.
     * @return {Promise<void>}
     */
    sign(transaction: Transaction, jwk?: JWKInterface | 'use_wallet', options?: SignatureOptions): Promise<void>;
    /**
     * Post a previously signed transaction to the network.
     * @param  {Transaction|Buffer|string|object} transaction - The transaction to post.
     * @returns {Promise} Returns a promise which resolves to `{status: number; statusText: string; data: any}`.
     */
    post(transaction: Transaction | Buffer | string | object): Promise<{
        status: number;
        statusText: string;
        data: any;
    }>;
    /**
     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
     * @param upload a Transaction object, a previously save progress object, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    getUploader(upload: Transaction | SerializedUploader | string, data?: Uint8Array | ArrayBuffer): Promise<TransactionUploader>;
    /**
     * Async generator version of uploader
     * @param {Transaction} upload a Transaction object, a previously save uploader, or a transaction id.
     * @param {Uint8Array} data the data of the transaction. Required when resuming an upload.
     */
    upload(upload: Transaction, data?: Uint8Array): AsyncGenerator<never, AsyncGenerator<TransactionUploader, TransactionUploader, unknown>, unknown>;
}
