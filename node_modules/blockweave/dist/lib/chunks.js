"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("../utils/buffer");
class Chunks {
    api;
    constructor(api) {
        this.api = api;
    }
    async getTransactionOffset(id) {
        const resp = await this.api.get(`tx/${id}/offset`);
        if (resp.status === 200) {
            return resp.data;
        }
        throw new Error(`Unable to get the transaction offset: ${resp.data ? resp.data.error || resp.statusText : 'unknown'}`);
    }
    async getChunk(offset) {
        const resp = await this.api.get(`${offset}/chunk`);
        if (resp.status === 200) {
            return resp.data;
        }
        throw new Error(`Unable to get the transaction chunk: ${resp.data ? resp.data.error || resp.statusText : 'unknown'}`);
    }
    async getChunkData(offset) {
        const chunk = await this.getChunk(offset);
        const buf = (0, buffer_1.b64UrlToBuffer)(chunk.chunk);
        return buf;
    }
    firstChunkOffset(offsetResponse) {
        return parseInt(offsetResponse.offset, 10) - parseInt(offsetResponse.size, 10) + 1;
    }
    async downloadchunkedData(id) {
        const offsetResponse = await this.getTransactionOffset(id);
        const size = parseInt(offsetResponse.size, 10);
        const endOffset = parseInt(offsetResponse.offset, 10);
        const startOffset = endOffset - size + 1;
        const data = new Uint8Array(size);
        let byte = 0;
        while (startOffset + byte < endOffset) {
            const chunkData = await this.getChunkData(startOffset + byte);
            data.set(chunkData, byte);
            byte += chunkData.length;
        }
        return data;
    }
}
exports.default = Chunks;
