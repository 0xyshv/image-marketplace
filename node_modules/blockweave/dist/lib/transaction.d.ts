import { TagInterface } from '../faces/lib/tag';
import { TransactionInterface } from '../faces/lib/transaction';
import { BaseObject } from '../utils/baseObject';
import { SignatureOptions } from '../faces/utils/crypto';
import { JWKInterface } from '../faces/lib/wallet';
import Blockweave from '../blockweave';
import { CreateTransactionInterface } from '../faces/blockweave';
export default class Transaction extends BaseObject implements TransactionInterface {
    readonly format: number;
    id: string;
    readonly last_tx: string;
    owner: string;
    tags: TagInterface[];
    readonly target: string;
    readonly quantity: string;
    readonly data_size: string;
    data: Uint8Array;
    data_root: string;
    reward: string;
    signature: string;
    chunks: any;
    private blockweave;
    private api;
    private merkle;
    private jwk;
    constructor(attributes: Partial<TransactionInterface>, blockweave: Blockweave, jwk?: JWKInterface | 'use_wallet');
    static create(blockweave: Blockweave, attributes: Partial<CreateTransactionInterface>, jwk: JWKInterface | 'use_wallet'): Promise<Transaction>;
    /**
     * Add a new tag to this transaction.
     * @param  {string} name
     * @param  {string} value
     */
    addTag(name: string, value: string): void;
    /**
     * Set the transaction to a new owner.
     * @param  {string} newOwner
     */
    setOwner(newOwner: string): void;
    /**
     * Set the signature of the transaction to a new one.
     * @param {string} id
     * @param {string} owner
     * @param {Tag[]} tags
     * @param {string} signature
     */
    setSignature({ id, owner, tags, signature }: Partial<TransactionInterface>): void;
    /**
     * Prepare the data as chunks.
     * @param  {Uint8Array} data
     */
    prepareChunks(data: Uint8Array): Promise<void>;
    /**
     * Returns a chunk in a format suitable for posting to /chunk.
     * @param  {number} idx
     * @param  {Uint8Array} data
     * @returns Chunk data formated for deploy.
     */
    getChunk(idx: number, data: Uint8Array): {
        data_root: any;
        data_size: any;
        data_path: string;
        offset: any;
        chunk: string;
    };
    getSignatureData(): Promise<Uint8Array>;
    /**
     * Verify a signed transaction.
     * @param  {Transaction} transaction
     * @returns {Promise<boolean>} A boolean value indicating whether the transaction is valid.
     */
    verify(): Promise<boolean>;
    /**
     * Sign a transaction with your wallet, to be able to post it to Blockweave.
     * @param {JWKInterface} jwk A JWK (Wallet address JSON representation) to sign the transaction with. Or 'use_wallet' to use the wallet from an external tool.
     * @param {SignatureOptions} options Signature options, optional.
     * @return {Promise<void>}
     */
    sign(jwk?: JWKInterface | 'use_wallet', options?: SignatureOptions): Promise<void>;
    /**
     * Post a previously signed transaction to the network.
     * @param {number} feePercent The transaction fee %, in AR.
     * @returns {Promise} Returns a promise which resolves to `{status: number; statusText: string; data: any}`.
     */
    post(feePercent?: number): Promise<{
        status: number;
        statusText: string;
        data: any;
    }>;
    /**
     * @param  {JWKInterface|'use_wallet'} jwk?
     * @param  {SignatureOptions} options?
     * @param  {number} feePercent?
     * @returns {Promise<{ status: number; statusText: string; data: any }>} Returns the response `status, statusText, data}.
     */
    signAndPost(jwk?: JWKInterface | 'use_wallet', options?: SignatureOptions, feePercent?: number): Promise<{
        status: number;
        statusText: string;
        data: any;
    }>;
    /**
     * Return an object with the same data as this class.
     * @returns - The transaction as a JSON object.
     */
    toJSON(): {
        format: number;
        id: string;
        last_tx: string;
        owner: string;
        tags: TagInterface[];
        target: string;
        quantity: string;
        data_size: string;
        data: string;
        data_root: string;
        reward: string;
        signature: string;
    };
    /**
     * @param  {number=0.1} feePercent
     */
    private chargeFee;
}
