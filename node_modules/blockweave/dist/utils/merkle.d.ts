/**
 * @see {@link https://github.com/BlockweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}
 */
import { Chunk, MerkleNode, LeafNode, Proof } from '../faces/utils/merkle';
export declare const MAX_CHUNK_SIZE: number;
export declare const MIN_CHUNK_SIZE: number;
export default class Merkle {
    generateTransactionChunks(data: Uint8Array): Promise<{
        data_root: Uint8Array;
        chunks: Chunk[];
        proofs: Proof[];
    }>;
    /**
     * Takes the input data and chunks it into mostly equal sized chunks.
     * The last chunk will be a bit smaller as it contains the remainder
     * from the chunk process.
     * @params {Uint8Array} data - The data to be split.
     */
    chunkData(data: Uint8Array): Promise<Chunk[]>;
    generateLeaves(chunks: Chunk[]): Promise<LeafNode[]>;
    generateProofs(root: MerkleNode): Promise<Proof[]>;
    computeRootHash(data: Uint8Array): Promise<Uint8Array>;
    generateTree(data: Uint8Array): Promise<MerkleNode>;
    buildLayers(nodes: MerkleNode[], level?: number): Promise<MerkleNode>;
    arrayFlatten<T = any>(input: T[]): T[];
    intToBuffer(note: number): Uint8Array;
    validatePath(id: Uint8Array, dest: number, leftBound: number, rightBound: number, path: Uint8Array): Promise<{
        offset: number;
        leftBound: number;
        rightBound: number;
        chunkSize: number;
    }>;
    bufferToInt(buffer: Uint8Array): number;
    arrayCompare(a: Uint8Array, b: Uint8Array): boolean;
    private hashBranch;
    private hash;
    private resolveBranchProofs;
}
