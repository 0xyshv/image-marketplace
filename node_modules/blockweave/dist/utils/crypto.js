"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("./buffer");
const crypto_1 = require("crypto");
class CryptoDriver {
    keyLength = 4096;
    publicExponent = new Uint8Array([0x01, 0x00, 0x01]);
    hashAlgorithm = 'SHA-256';
    driver;
    constructor() {
        if (typeof crypto !== 'undefined') {
            this.driver = crypto.subtle;
        }
        if (!this.driver) {
            // @ts-ignore
            this.driver = crypto_1.webcrypto.subtle;
        }
    }
    async generateJWK() {
        const cryptoKey = await this.driver.generateKey({
            name: 'RSA-PSS',
            modulusLength: this.keyLength,
            publicExponent: this.publicExponent,
            hash: this.hashAlgorithm,
        }, true, ['sign']);
        const jwk = await this.driver.exportKey('jwk', cryptoKey.privateKey);
        return {
            kty: jwk.kty,
            e: jwk.e,
            n: jwk.n,
            d: jwk.d,
            p: jwk.p,
            q: jwk.q,
            dp: jwk.dp,
            dq: jwk.dq,
            qi: jwk.qi,
        };
    }
    async sign(jwk, data, signOpts = {}) {
        const signature = await this.driver.sign({
            name: 'RSA-PSS',
            saltLength: 32,
        }, await this.jwkToCryptoKey(jwk), data);
        return new Uint8Array(signature);
    }
    async hash(data, algorithm = this.hashAlgorithm) {
        const digest = await this.driver.digest(algorithm, data);
        return new Uint8Array(digest);
    }
    async verify(publicModulus, data, signature) {
        const publicKey = {
            kty: 'RSA',
            e: 'AQAB',
            n: publicModulus,
        };
        const key = await this.jwkToPublicCryptoKey(publicKey);
        const verifyWith32 = this.driver.verify({
            name: 'RSA-PSS',
            saltLength: 32,
        }, key, signature, data);
        const verifyWith0 = this.driver.verify({
            name: 'RSA-PSS',
            saltLength: 0,
        }, key, signature, data);
        return verifyWith32 || verifyWith0;
    }
    async encrypt(data, key, salt) {
        const intialKey = await this.driver.importKey('raw', typeof key === 'string' ? (0, buffer_1.stringToBuffer)(key) : key, {
            name: 'PBKDF2',
            length: 32,
        }, false, ['deriveKey']);
        const derivedKey = await this.driver.deriveKey({
            name: 'PBKDF2',
            salt: salt ? (0, buffer_1.stringToBuffer)(salt) : (0, buffer_1.stringToBuffer)('salt'),
            iterations: 100000,
            hash: this.hashAlgorithm,
        }, intialKey, {
            name: 'AES-CBC',
            length: 256,
        }, false, ['encrypt', 'decrypt']);
        const iv = new Uint8Array(16);
        crypto.getRandomValues(iv);
        const encryptedData = await this.driver.encrypt({
            name: 'AES-CBC',
            iv,
        }, derivedKey, data);
        return (0, buffer_1.concatBuffers)([iv, encryptedData, encryptedData]);
    }
    async decrypt(encrypted, key, salt) {
        const intialKey = await this.driver.importKey('raw', typeof key === 'string' ? (0, buffer_1.stringToBuffer)(key) : key, {
            name: 'PBKDF2',
            length: 32,
        }, false, ['deriveKey']);
        const derivedKey = await this.driver.deriveKey({
            name: 'PBKDF2',
            salt: salt ? (0, buffer_1.stringToBuffer)(salt) : (0, buffer_1.stringToBuffer)('salt'),
            iterations: 100000,
            hash: this.hashAlgorithm,
        }, intialKey, {
            name: 'AES-CBC',
            length: 256,
        }, false, ['encrypt', 'decrypt']);
        const iv = encrypted.slice(0, 16);
        const data = await this.driver.decrypt({
            name: 'AES-CBC',
            iv,
        }, derivedKey, encrypted.slice(16));
        return new Uint8Array(data);
    }
    async jwkToCryptoKey(jwk) {
        return this.driver.importKey('jwk', jwk, {
            name: 'RSA-PSS',
            hash: this.hashAlgorithm,
        }, false, ['sign']);
    }
    async jwkToPublicCryptoKey(publicJwk) {
        return this.driver.importKey('jwk', publicJwk, {
            name: 'RSA-PSS',
            hash: this.hashAlgorithm,
        }, false, ['verify']);
    }
}
exports.default = CryptoDriver;
